# 准备：网络通信

## 1. DNS

* 浏览器缓存，系统缓存，路由器缓存，本地域名服务器缓存，根域名服务器，顶级域名服务器，主域名服务器，保存结果至缓存。
* 递归：只发一次请求，要求对方给出最终结果。例如主机向本地域名服务器的查询。
* 迭代：发出一次请求，对方如果没有答案，它就会返回一个能解答这个查询的其它名称服务器列表。本地域名服务器向根域名服务器的查询的查询。

## 2. 从输入url到网页显示的过程中发生了什么？

1. DNS查询
2. TCP握手
3. TLS握手
4. 请求资源：200继续解析；300重定向；400客户端错误；500服务端错误
5. HTML解析器将html文档解析为DOM树。
6. 解析CSS，构建CSSOM
7. 将DOM和cssom合并为渲染树
8. 渲染树布局
9. 渲染树绘制   

## 3. HTTPS 是如何实现安全性的

1. **加密\(Encryption\)**， HTTPS 通过对数据加密来使其免受窃听者对数据的监听，这就意味着当用户在浏览网站时，没有人能够监听他和网站之间的信息交换，或者跟踪用户的活动，访问记录等，从而窃取用户信息。      RSA 的运算速度非常慢，而 AES 的加密速度比较快， TLS 使用了混合加密方式。在通信刚开始的时候使用非对称算法，首先解决密钥交换的问题。然后用随机数产生对称算法使用的会话密钥（session key），再用公钥加密。对方拿到密文后用私钥解密，取出会话密钥。这样，双方就实现了对称密钥的安全交换。
2. **数据一致性\(Data integrity\)**，数据在传输的过程中不会被窃听者所修改，用户发送的数据会完整的传输到服务端，保证用户发的是什么，服务器接收的就是什么。 在 TLS 中，实现完整性的手段主要是**摘要算法**\(Digest Algorithm\)。
3. **身份认证\(Authentication\)**，是指确认对方的真实身份，也就是证明你是你（可以比作人脸识别） ，它可以防止中间人攻击并建立用户信任。数字签名，颁发数字证书解决公钥的信任问题。
4. 参考：[https://www.cnblogs.com/cxuanBlog/p/12490862.html](https://www.cnblogs.com/cxuanBlog/p/12490862.html)

## 4. GET 和 POST 的区别

1. 参考：99%的人都理解错了 HTTP 中 GET 与 POST 的区别  [https://learnku.com/articles/25881](https://learnku.com/articles/25881)
2. 这个文章揭开了 HTTP 请求类型的本质，但我还没打算细看。

## 5. HTTP 响应码

1. 信息响应 100：continue
2. 成功响应 200：OK
3. 重定向 300：multiple choice 301:   move permanently 永久性转移 302：move Temporarily 暂时性转移
4. 客户端响应 400：Bad request 403：Forbidden ****404：Not Found
5. 服务端响应 500：Internal service error 502：Bad Gateway 503：Service Unavliable

## 6. CSRF 攻击

CSRF（cross site request forgery）跨站请求伪造攻击。攻击者通过引导某一网站的使用者进入第三方网站，向攻击网站发送跨站请求，利用用户已经获得的登录注册凭证，绕过后台验证，达到冒充用户对被攻击的网站执行某项操作的目的。  
参考：[https://tech.meituan.com/2018/10/11/fe-security-csrf.html](https://tech.meituan.com/2018/10/11/fe-security-csrf.html)

* CSRF（通常）发生在第三方网站
* CSRF攻击者不能获取到Cookie等信息，只是使用。
* 防护策略
  * 阻止不明外域的访问
    * 同源检测 √
    * samesite cookie ？
  * 提交时附加本域才能获取的信息
    * CSRF token ？
    * 双重 cookie 验证 ？

## 7. 同源检测

1. 同源：协议、域名、端口完全相同
2. 同源策略：一种简单的防范CSRF攻击的方法，由浏览器执行，主要规则有：
   1. 无法用js读取非同源的Cookie、LocalStorage 和 IndexDB 无法读取。 
   2. 无法用js获取非同源的DOM。 
   3. 无法用js发送非同源的AJAX请求 。

## 8. 跨域方案

1. **CORS 跨域资源共享**
   1. 在HTTP协议中，每一个异步请求都会带上两个header，用于标记来源域名，分别是origin和referer。这个字段是由浏览器添加的，不能由前端自定义修改，这很重要。
   2. 后端收到请求之后，对origin字段进行校验，如果后端在CORS白名单中没有找到该地址，则发送不包含Access-Control-Allow-Origin字段的响应报文，表示不允许请求资源。
   3. 值得注意的是，这种情况下响应码仍然是200，因为服务端确实响应了报文，不过当前端识别不到Access-Control-Allow-Origin字段后，会在控制台报错。
   4. 在阻止外域请求时，为了网页的初次展示，服务器往往会过滤掉页面请求。相应的，页面请求暴露在攻击范围内。如果使用GET请求实现产品功能，同样会受到CSRF攻击。
2. **JSONP 跨域**
   1. 利用浏览器不限制script标签跨域请求的特性，把请求设计为script标签添加到 head 中，标签中可设置回调函数。
   2. 只能发送get请求。//个人认为，黑客无法从JSONP进行CSRF攻击。

## 9. XSS 攻击

1. Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。
2. 向 DOM 注入script代码实现攻击，通常使用HTML转义解决。对于页面中所有用户输入的内容，都要进行HTML转义。
3. 参考：[https://tech.meituan.com/2018/09/27/fe-security.html](https://tech.meituan.com/2018/09/27/fe-security.html)

## 10. HTTP 各个版本

### HTTP 1.0

1. 默认短连接
2. 基于TCP
3. 发出一个请求之后，等待响应后才能继续发送下一个请求。
4. 使用文本格式

### HTTP 1.1

1. 默认长连接
2. 管线化技术：同一个TCP连接可同时发出多个HTTP请求，但只能按照发送顺序来接受响应，这要求服务端按顺序处理请求，按顺序返回，客户端无法识别。
3. 一个新的http请求既可以加入tcp队列，也可以新建一个tcp连接。
4. 浏览器在同一时间对同一域名的TCP连接的数量受限制，一个独立的用户最多建立2个TCP连接，代理主机可以建立2\*N个TCP连接（N是使用代理的用户数量），超过限制数量的请求会被阻塞。这与服务器的链接压力有关。为绕开这一限制，许多网站会设置多个静态CDN资源域名。

### HTTP2.0

1. 多路复用：允许在同一TCP连接中同时发起多个请求，解决队头阻塞。
2. 抛弃文本格式，使用二进制格式。

## TCP

### 三次握手

1. 过程： A-&gt;B \[SYN=1 SEQ=0\] B-&gt;A \[SYN=1 SEQ=0 ACK=1\] A-&gt;B \[SEQ=1 ACK=1\]
2. 重传机制：
   1. 携带数据的segment在一段时间内没有收到ack时，会触发重传机制。
   2. 在握手阶段，携带SYN字段的segment相当于有一个字节的数据包，因此前两次握手都有超时重传机制。
   3. 我觉得第三次之所以没有携带数据，是因为他不需要ack，如果第三次也需要ack，那必然有第四次，那就无穷无尽了。
3. 必要性：
   1. 三次重传可以保证双方都拿到对方的序列码，第一次丢失A重传，第二次丢失A或B重传，第三次丢失B重传。
   2. 如果只有两次，双方可能没有对B的序列码达成一致，那么此时由B发往A的包就是不可靠的；相对的，A的序列码已经达成一致，A是可以放心往B发送segment的。

### 四次挥手

1. 和上面的道理一样，第一次和第三次都有FIN码，二四没有，因为他们不需要acknowledge。第四次挥手的必要性就体现在，如果第三个包丢失，服务端会重传，如果第四个包丢失，服务端依然重传。如果只有三次挥手，没人需要ack，那服务端悄悄下线，客户端收没收到也不知道。
2. 客户端等待两个最长报文寿命是因为，当第四个包丢失后，服务端会再重发FIN，如果这个时候客户端下线就无法响应了，所以等待两个最长报文寿命。



