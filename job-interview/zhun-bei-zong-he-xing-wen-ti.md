---
description: 这一部分比较杂，不属于特别原理性的知识点
---

# 准备：综合性问题

### 判断数组的方法

1. constructor
2. Array.isArray
3. instance of
4. object.prototype.toString.call\(\)

### 面向对象、面向过程、函数式编程

面向对象是指将特定的属性和方法封装到对应的类中，在主函数调用时，无需关心方法的具体实现。  
面向对象的三大特性是：封装、继承、多态。

面向过程是具体化的，流程化的。

函数式编程，把所有方法封装在纯函数中，通过流水线的方式执行逻辑。  
纯函数的两大特性，无副作用和无状态（时不变），可以很好地提高编程效率，提高代码质量，降低维护难度。  
ES6 推出的箭头函数，没有 this 指向，这保证了函数的无状态。  
React 强推 Hook ，鼓励开发者用 pure function 编写组件。但我认为，react 组件不算真正意义上的纯函数，毕竟还是需要维护状态的。没有副作用倒是真的。

### 二叉树：层序遍历

力扣：[https://leetcode-cn.com/problems/binary-tree-level-order-traversal/submissions/](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/submissions/)  
一层遍历使用两个队列交替记录；两层遍历使用一个队列记录  
js 数组的 shift 方法可以取出第一个元素并移除队列

### 二叉树：后序遍历

使用递归方法比较简单。  
使用栈记录可以在循环内完成遍历。

### ES6 class 与 ES5 function

class 的功能完全可以用 ES5 的函数和原型链实现

```text
// ES6 class
class A{
    static a=1;
    b=2;
}

class B extends A{
    constructor(){
        super();
        this.c=5;
    }
    func1(){
        console.log(this.constructor.a,this.b,this.c)
    }
}

// test example
b=new B()
b.func1()

//ES5 function
function A(){
    this.b=2;
}
A.a=1;

function B(){
    A.call(this);
    this.c=5;
}
B.prototype=new A()

B.prototype.func1=function(){
    console.log(this.constructor.a,this.b,this.c)
}
```

### ES6 新特性

1. let、const：块级作用域
2. 模板字符串：“this is ${name} ."
3. 箭头函数
4. 函数默认值
5. spread/Rest：...array
6. 二进制和八进制
7. 对象和数组解构：\[a,b,c\]=array、{a,b,c}=object
8. for of 遍历迭代器, for in 遍历对象和数组
9. 类：语法糖

### reduce 方法

和 map 相对于，reduce 用于归并数组内容，应用场景很广泛。核心功能在于，reduce 在遍历一个数组的过程中，能够把上一次迭代时 return 的内容传递到下一次迭代中，以实现归并的功能。reduce 方法的第一个参数是回调函数，接受四个参数：prev、curv、index、arr，第二个参数是 initial value ，作为第一个位置的 prev 参数，有设置initial value 比较合理，否则则跳过第一个位置的回调执行。

### 开发过程是否遇到难题？如何解决？

识图作诗这个项目我觉得亮点可能在于这个创意吧，包括小程序除了匹配相关古诗词，还有实现一些辅助功能，例如注释、诗词卡片，不过缺点也在于，核心功能的算法不能很好的实现这个创意，首先是对古诗词中的语义挖掘不充分，项目中使用的是文本匹配，但古诗词有一个特点就是充满了各自比喻暗喻等修辞手法，可能去匹配“女孩”可能匹配不到太多好的诗词，真的描写女性之美的诗词都是不会直白指明的。第二个问题是现代汉语和古代汉语的语料库没有打通，可能一个词在古代有多种不同的说法，需要处理好这层映射。在开发中遇到的难点的话，我当时做这个项目时开发经验不多，对前后端的认识也不是很充分，所以在那之前我做的开发都是无后台的，使用小程序云数据库存储数据，然后在前端调用数据库请求接口。但是这个项目我有一个需求是爬虫，做爬虫的话我更倾向于使用python 完成，所以我就想，不能把所有业务逻辑都放在前端了，前端应当只是做和用户的交互，其他工作应该交给后端去做，所以我就去了解了腾讯云的云函数托管，serverless，经过实践，我就比较清晰地认识到了前后端的关系以及职能。

对于校园学习平台这个项目，我觉得相对于其他几个项目来说比较中规中矩，可能这个项目重在产品设计上，我们当时团队有七人，我是作为开发人员参与的，团队有三四位同学是负责产品构思的，会做需求调研之类的工作。所以我作为开发人员来说，遇到的困难没有那么多。可能有一点可以提及的是，我们在项目中的登录功能使用了小程序的鉴权机制，那么将用户的openid只在后端使用，保护数据安全。也方便了用户，不需要设置密码。

编译系统项目有一个小插曲，让我一人独自完成了两个part, balabala......

我之前有一次为一个社团活动做一个扫码签到的demo，业务场景是，到场的同学扫描公共二维码，获得一个唯一的ID，这个ID用于会后领取讲座票以及中场抽奖，所以这个ID必须保证唯一并且不超过200个，先到先得。我是用小程序云数据库存的数据，前端调用云数据库的接口，当时在写分配ID的代码时，我就遇到一个问题，小程序开发文档中有一个inc函数，用于数据库中整数字段的自增，我认为这个是适合用于统计人数和分配序号的，在多个用户同时扫码时不会造成冲突。但这个函数有一个问题，他在完成自增之后并不会给回调函数返回当前值，也就意味着，修改操作和查询操作是分离的，可能在修改和查询两个操作中间，有其他用户对数据进行了修改，虽然在服务端对用户的统计是正确的，但用户查询到的序号不一定是正确的。 当时为了解决这个问题，查了很多资料以及在开发社区提问，有相同的提问帖，但都没有找到解决方法。所以我去请教了一个云开发团队的开发人员，他返回给我一个云开发团队开发的nodejs SDK文档，这个SDK中的inc函数就实现了真正的原子自增。 这个经历还蛮有趣的，如果我自己一个人钻研，那我关注的都是如何利用当前这个小程序开发SDK解决问题，很难想到小程序的云数据库有另一个版本的SDK实现。  
不过，这个产品没有应用，没有说服上级，因为担心出现二维码外传。

